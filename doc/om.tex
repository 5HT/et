% copyright (c) 2015 Synrc Research Center

\documentclass[11pt,oneside]{article}

\input{synrc.tex}
\begin{document}

\thispagestyle{empty}
\begin{center}

\begin{minipage}[t]{2cm}
    \includegraphics[scale=0.4]{img/S}
\end{minipage}
\begin{minipage}[t]{12cm}
    \begin{flushright}
        \textsc{{\Large {\bf {\color{Blue}syn}{\color{OrangeRed}rc} research center s.r.o.}}}\\
        \textsc{Roháčova 141/18, Praha 3 13000, Czech Republic}\\
    \end{flushright}
\end{minipage}

\vspace{3cm}

    \vspace{3cm}   {\Large \bf Intermediate Language with Dependent Types for Erlang/OTP applications.\\}\par
    \vspace{0.3cm} {\Large Technical Article\par}
    \vspace{0.3cm} {\Large Maxim Sokhatsky, Synrc Research Center\par}
    \vspace{4cm}   {\Large Kyiv 2017}

\end{center}

\newpage
\vspace{2cm}
\tableofcontents
\newpage
\section{Introduction}

\vspace{1cm}

%\vspace{0.5cm}

\paragraph{}
{\bf LISP}. Untyped lambda calculus was discovered as an inner language of the space
at origin (Curry, Church, 1932). This language was manifested as LISP (McCarthy, 1958)
that was built upon: cons, nil, eq, atom, car, cdr, lambda, apply and id.
It was parts of inductive types lately known as inductive type constructors.
Still untyped lambda calculus is used as an extraction target for many
provers (Idris, F*), and also manifests in different domain languages (JavaScript, Erlang).

\paragraph{}
{\bf ML/LCF}. Further teardown of inner space language was ML language, founded merely on algebraic
datatypes and algebra on higher terms rather than categorical semantic. Lately it
was fixed with categorical methods in CPL (Hagino, 1987) and Charity (Cockett, 1992).
Milner, assisted by Morris and Newey designed Meta Language for the purpose of builing LCF
in early 70-s. LCF was a predecessor family of automated math provers: HOL88,
HOL90, HOL98 and HOL/Isabelle which is now built using Poly/ML.

\paragraph{}
{\bf Fully Automated Provers}. In that period during 80-90s other automated math systems were appeared:
AUTOMATH (de Bruijn, 1967), Mizar (Trybulec, 1989), PVS (Owre, Rushby, Shankar, 1995),
ACL2 (Boyer, Kaufmann, Moore, 1996) and Otter (McCune, 1996).

\paragraph{}
{\bf MLTT}. Contemporary provers (built upon consistent Martin-Löf Type Theory, 1972)
like Agda, Coq, Lean, F*, Idris are based on Barendregt
and Coquand' CoC with different flavours of inifinity universe hierarchies
and Calculus of Inductive Constructions. Some of them are automated and some
are trying to be and general purpose programming languages with proving facilities.

\newpage
\section{Motivation}

\paragraph{}
{\bf From PTS to HTS}. We want to have flexible detachable
layers on top of PTS core. Then Sigma for proving.
Then well-founded trees or polynomial functors as known as data and record.
Then higher path types, interval arithmetic, glue and comp for HIT.
Each layers is driven by differenth math, the common in only the method -- category theory.

\paragraph{}
{\bf Extensible Language Design}. Encoding of inductive types is based on categorical
semantic of compilation to PTS. All other syntax constructions are inductive
definitions, plugged into the stream parser. AST of the PTS language is also
defined in terms of inductive constructions and thus allowed in the macros.
The language of polynomial functors (data and record) and core language of
the process calculus (spawn, receive and send) are just macrosystem over Om language,
its syntax extensions.

\paragraph{}
{\bf Changable Encodings}. In pure CoC we have only arrows, so all inductive type encodings would
be Church-encoding variations. Most extended nowadays is Church-Boehm-Berrarducci encoding,
which dedicated to inductive types. Another well known are Scott (lazyness),
Parigot (lazyness and constant-time iterators) and CPS (continuations) encodings.
However most of them require variations of Fixpoint types.

\paragraph{}
{\bf Proved Categorical Semantic}. There was modeled a math model (using
higher-order categorical logic) of encoding, which calculates (co)limits in a
cathegory of (co)algebras built with given set of (de)constructors.
We call such encoding in honour of Lambek lemma that leeds us to the
equality of (co)initial object and (co)limit in the categories of (co)algebras.
Such encoding works with dependent types and its consistency is proved in Lean model.

\newpage
\section{Intermediate Language Om}

   \paragraph{}
   The Om language is a dependently typed lambda calculus, an extension of Barendregt'
   and Coquand Calculus of Constructions with predicative hierarchy of indexed universes.
   There is no fixpoint axiom needed for the definition of infinity term dependance.

   \paragraph{}
   All terms respect ranking $Axioms$ inside sequence of universes $Sorts$ and complexity of the
   dependent term is equal maximum complexity of term and its dependency $Rules$. The type
   system is completely described by the following PTS notation (due to Barendregt):

$$
\begin{cases}
    Sorts = Type.\{i\},\ i : Nat\\
    Axioms = Type.\{i\} : Type.\{inc\ i\}\\
    Rules = Type.\{i\} \leadsto Type.\{j\} : Type.\{max\ i\ j\}\\
\end{cases}
$$

   \paragraph{}
   An intermediate Om language is based on Henk\cite{henk} languages described first
   by Erik Meijer and Simon Peyton Jones in 1997. Leter on in 2015 Morte impementation
   of Henk design appeared in Haskell, using Boem-Berrarducci encoding of non-recursive lambda terms.
   It is based only on one type constructor $\Pi$, its special case $\lambda$ and theirs eliminators:
   $apply$ and $curry$, infinity number of universes,
   and one computation rule called $\beta$-reduction.
   The design of Om language resemble Henk and Morte both
   design and implementation. This language indended to be small, concise, easy provable
   and able to produce verifiable peace of code that can be distributed over the networks,
   compiled at target with safe trusted linkage.

   \subsection{BNF}
\vspace{0.5cm}
   Om syntax is compatible with $\lambda C$ Coquand's Calculus of Constructions presented
   in Morte and Henk languages. However it has extension in a part of specifying
   universe index as a {\bf Nat} number.

\vspace{0.5cm}
\begin{lstlisting}[mathescape=true]
   <> ::= #option
    I ::= #identifier
    U ::= * < #number >
    O ::= U
        | I | ( O ) | O O | O $\rightarrow$ O
        | $\lambda$ ( I : O ) $\rightarrow$ O
        | $\forall$ ( I : O ) $\rightarrow$ O
\end{lstlisting}

\newpage

   \subsection{Hierarchy}

\begin{lstlisting}[mathescape=true]
dep Arg Out impredicative $\rightarrow$ Out
dep Arg Out predicative   $\rightarrow$ max Arg Out

h Arg Out $\rightarrow$ dep Arg Out om:hierarchy(impredicative)
\end{lstlisting}

   \subsection{Universes}

\begin{lstlisting}[mathescape=true]
star (:star,N) $\rightarrow$ N
star _         $\rightarrow$ (:error, "*")
\end{lstlisting}

   \subsection{Functions}

\begin{lstlisting}[mathescape=true]
func ((:forall,),(I,O)) $\rightarrow$ true
func T                  $\rightarrow$ (:error,(:forall,T))
\end{lstlisting}

   \subsection{Variables}

\begin{lstlisting}[mathescape=true]
var N B                $\rightarrow$ var N B (proplists:is_defined N B)
var N B true           $\rightarrow$ true
var N B false          $\rightarrow$ (:error,("free var",N,proplists:get_keys(B)))
\end{lstlisting}

   \subsection{Shift}

\begin{lstlisting}[mathescape=true]
sh (:var,(N,I)),N,P) when I>=P  $\rightarrow$ (var,(N,I+1))
sh ((:forall,(N,0)),(I,O)),N,P) $\rightarrow$ ((:forall,(N,0)),sh I N P,sh O N P+1)
sh ((:lambda,(N,0)),(I,O)),N,P) $\rightarrow$ ((:lambda,(N,0)),sh I N P,sh O N P+1)
sh (Q,(L,R),N,P)                $\rightarrow$ (Q,sh L N P,sh R N P)
sh (T,N,P)                      $\rightarrow$ T
\end{lstlisting}

   \subsection{Substitution}

\begin{lstlisting}[mathescape=true]
sub Term Name Value               $\rightarrow$ sub Term Name Value 0
sub (:arrow,         (I,O)) N V L $\rightarrow$ (:arrow,         sub I N V L,sub O N V L);
sub ((:forall,(N,0)),(I,O)) N V L $\rightarrow$ ((:forall,(N,0)),sub I N V L,sub O N(sh V N 0)L+1)
sub ((:forall,(F,X)),(I,O)) N V L $\rightarrow$ ((:forall,(F,X)),sub I N V L,sub O N(sh V F 0)L)
sub ((:lambda,(N,0)),(I,O)) N V L $\rightarrow$ ((:lambda,(N,0)),sub I N V L,sub O N(sh V N 0)L+1)
sub ((:lambda,(F,X)),(I,O)) N V L $\rightarrow$ ((:lambda,(F,X)),sub I N V L,sub O N(sh V F 0)L)
sub (:app,           (F,A)) N V L $\rightarrow$ (:app,sub F N V L,sub A N V L)
sub (:var,           (N,L)) N V L $\rightarrow$ V
sub (:var,           (N,I)) N V L when I>L $\rightarrow$ (:var,(N,I-1))
sub T                       _ _ _ $\rightarrow$ T.
\end{lstlisting}

   \subsection{Normalization}

\begin{lstlisting}[mathescape=true]
norm :none                   $\rightarrow$ :none
norm :any                    $\rightarrow$ :any
norm (:app,(F,A))            $\rightarrow$ case norm F of
                                ((:lambda,(N,0)),(I,O)) $\rightarrow$ norm (subst O N A)
                                                     NF $\rightarrow$ (:app,(NF,norm A)) end
norm (:remote,N)             $\rightarrow$ cache (norm N [])
norm (:arrow,         (I,O)) $\rightarrow$ ((:forall,("_",0)),(norm I,norm O))
norm ((:forall,(N,0)),(I,O)) $\rightarrow$ ((:forall,(N,0)),    (norm I,norm O))
norm ((:lambda,(N,0)),(I,O)) $\rightarrow$ ((:lambda,(N,0)),    (norm I,norm O))
norm T                       $\rightarrow$ T
\end{lstlisting}

   \subsection{Definitional Equality}

\begin{lstlisting}[mathescape=true]
eq ((:forall,("_",0)), X) (:arrow,Y)     $\rightarrow$ eq X Y
eq (:app,(F1,A1))         (:app,(F2,A2)) $\rightarrow$ let true = eq F1 F2 in eq A1 A2
eq (:star,N)              (:star,N)      $\rightarrow$ true
eq (:var,(N,I))           (:var,(N,I))   $\rightarrow$ true
eq (:remote,N)            (:remote,N)    $\rightarrow$ true
eq ((:farall,(N1,0)),(I1,O1))
   ((:forall,(N2,0)),(I2,O2)) $\rightarrow$
   let true = eq I1 I2 in eq O1 (subst (shift O2 N1 0) N2 (:var,(N1,0)) 0)
eq ((:lambda,(N1,0)),(I1,O1))
   ((:lambda,(N2,0)),(I2,O2)) $\rightarrow$
   let true = eq I1 I2 in eq O1 (subst (shift O2 N1 0) N2 (:var,(N1,0)) 0)
eq (A,B)                      $\rightarrow$ (:error,(:eq,A,B))
\end{lstlisting}

   \subsection{Type Checker}

\begin{lstlisting}[mathescape=true]
type (:star,N)               _ $\rightarrow$ (:star,N+1)
type (:var,(N,I))            D $\rightarrow$ let true = var N D in keyget N D I
type (:remote,N)             D $\rightarrow$ cache type N D
type (:arrow,(I,O))          D $\rightarrow$ (:star,h(star(type I D)),star(type O D))
type ((:forall,(N,0)),(I,O)) D $\rightarrow$ (:star,h(star(type I D)),star(type O [(N,norm I)|D]))
type ((:lambda,(N,0)),(I,O)) D $\rightarrow$ let star (type I D),
                                  NI = norm I in ((:forall,(N,0)),(NI,type(O,[(N,NI)|D])))
type (:app,(F,A))            D $\rightarrow$ let T = type(F,D),
                                  true = func T,
                                  ((:forall,(N,0)),(I,O)) = T,
                                  Q = type A D,
                                  true = eq I Q in norm (subst O N A)
\end{lstlisting}


\subsection{Target Erlang VM and LLVM platforms}

   \paragraph{}
   This works expect to compile to limited target platforms. For now Erlang, Haskell and LLVM is awaiting.
   Erlang version is expected to be useful both on LING and BEAM Erlang virtual machines.

\newpage
   \section{Exe Macrosystem}

   Exe is a general purpose functional language with functors, lambdas on types, recursive algebraic types,
   higher order functions, corecursion, free monad for effects encoding. It compilers
   to a small core of dependent type system without recursion called Om.
   This language intended to be useful enough to encode KVS (database), N2O (web framework) and
   BPE (processes) applications.

   \subsection{Compiler Passes}

   The underlying OM typechecker and compiler is a target language for EXE general purpose language.
   \begin{center}
   \begin{tabular}{ll}
   EXPAND  & EXE -- Macroexpansion\\
   NORMAL  & OM -- Term normalization and typechecking\\
   ERASE   & OM -- Delete information about types\\
   COMPACT & OM -- Term Compactification\\
   EXTRACT & OM -- Extract Erlang Code\\
   \end{tabular}
   \end{center}

   \subsection{BNF}

\begin{lstlisting}[mathescape=true]
    <> ::= #option
    [] ::= #list
     I ::= #identifier
     U ::= * < #number >
     O ::= I | ( O ) |
           U | O $\rightarrow$ O | O O
             | $\lambda$ ( I : O ) $\rightarrow$ O
             | $\forall$ ( I : O ) $\rightarrow$ O
     L ::= I | L I
     A ::= O | A $\rightarrow$ A | ( L : O )
     F ::= $\empty$ | F ( I : O ) | ()
     E ::= O | E data L : A := F
             | E record L : A < extend F > := F
             | E let F in E
             | E case E [ | I O $\rightarrow$ E ]
             | E receive E [ | I O $\rightarrow$ E ]
             | E spawn E raise L := E
             | E send E to E
\end{lstlisting}

\newpage
   \subsection{Inductive Types}

  \paragraph{}
  There is two types of recursion: one is least fixed point (as $F_A\ X = 1 + A\times X$ or $F_A\ X = A + X\times X$),
  in other words the recursion with a base (terminated with a bounded value), lists are trees are
  examples of such recursive structures (so we call induction recursive sums); and the second
  is greatest fixed point or recursion withour base (as $F_A\ X = A\times X $) --- such kind of
  recursion on infinite lists (codata, streams, coinductive types) we can call recursive products.\\
\\
  Natural Numbers: $\mu\ X \rightarrow 1 + X$ \\
  List A: $\mu\ X \rightarrow 1 + A \times X$ \\
  Lambda calculus: $\mu\ X \rightarrow 1 + X \times X + X$ \\
  Stream: $\nu\ X \rightarrow A \times X$ \\
  Potentialy Infinite List A: $\nu\ X \rightarrow 1 + A \times X$ \\
  Finite Tree: $\mu\ X \rightarrow \mu\ Y \rightarrow 1 + X \times Y = \mu\ X = List\ X$ \\

  \paragraph{}
  As we know there are several ways to appear for variable in recursive algebraic type.
  Least fixpoint are known as an recursive expressions that have a base of recursion
  Both recursive and corecursive datatypes could be encoded using Boem-Berarducci encoding
  as an non-recursive definitions of folds that include in indentity signature all the
  constructor components of (co)inductive type.

  \subsection{Lists}
  The data type of lists over a given set A can be represented as the initial algebra
  $(\mu L_A, in)$ of the functor $L_A(X) = 1 + (A \times X)$. Denote $\mu L_A = List(A)$.
  The constructor functions $nil: 1 \rightarrow List(A)$ and
  $cons: A \times List(A) \rightarrow List(A)$ are defined by
  $nil = in \circ inl$ and $cons = in \circ inr$, so $in = [nil,cons]$.
  Given any two functions $c: 1 \rightarrow C$ and $h: A \times C \rightarrow C$,
  the catamorphism $f = \llparenthesis [c,h] \rrparenthesis : List(A) \rightarrow C$
  is the unique solution of the equation system:
\vspace{0.3cm}
$$
\begin{cases}
  f \circ nil  = c \\
  f \circ cons = h \circ (id \times f)
\end{cases}
$$

\paragraph{}
  where $f = foldr(c,h)$. Having this the initial algebra is presented with functor
  $\mu (1 + A \times X)$ and morphisms sum $[1 \rightarrow List(A), A \times List(A) \rightarrow List(A)]$
  as catamorphism. Using this encdoding the base library of List will have following form:

\vspace{0.5cm}
$$
\begin{cases}
 foldr = \llparenthesis [ f \circ nil , h] \rrparenthesis, f \circ cons = h \circ (id \times f)\\
 len = \llparenthesis [ zero, \lambda\ a\ n \rightarrow succ\ n ] \rrparenthesis \\
 (++) = \lambda\ xs\ ys \rightarrow \llparenthesis [ \lambda (x) \rightarrow ys, cons ] \rrparenthesis (xs) \\
 map = \lambda\ f \rightarrow \llparenthesis [ nil, cons \circ (f \times id)] \rrparenthesis
\end{cases}
$$

\begin{lstlisting}[mathescape=true]
             data list: (A: *) $\rightarrow$ * :=
                  (nil: list A)
                  (cons: A $\rightarrow$ list A $\rightarrow$ list A)
\end{lstlisting}
$$
\begin{cases}
list = \lambda\ ctor \rightarrow \lambda\ cons \rightarrow \lambda\ nil \rightarrow ctor\\
cons = \lambda\ x\ \rightarrow \lambda\ xs \rightarrow \lambda\ list \rightarrow \lambda\ cons \rightarrow\ \lambda\ nil \rightarrow cons\ x\ (xs\ list\ cons\ nil)\\
nil = \lambda\ list \rightarrow \lambda\ cons \rightarrow \lambda\ nil \rightarrow nil\\
\end{cases}
$$
\begin{lstlisting}[mathescape=true]
           record lists: (A B: *) :=
                  (len: list A $\rightarrow$ integer)
                  ((++): list A $\rightarrow$ list A $\rightarrow$ list A)
                  (map: (A $\rightarrow$ B) $\rightarrow$ (list A $\rightarrow$ list B))
                  (filter: (A $\rightarrow$ bool) $\rightarrow$ (list A $\rightarrow$ list A))
\end{lstlisting}
$$
\begin{cases}
len = foldr\ (\lambda\ x\ n \rightarrow succ\ n)\ 0\\
(++) = \lambda\ ys \rightarrow foldr\ cons\ ys\\
map = \lambda\ f \rightarrow foldr\ (\lambda x\ xs \rightarrow cons\ (f\ x)\ xs)\ nil\\
filter = \lambda\ p \rightarrow foldr\ (\lambda x\ xs \rightarrow if\ p\ x\ then\ cons\ x\ xs\ else\ xs)\ nil\\
foldl = \lambda\ f\ v\ xs = foldr\ (\lambda\ xg\rightarrow\ (\lambda \rightarrow g\ (f\ a\ x)))\ id\ xs\ v\\
\end{cases}
$$

\vspace{1cm}
\subsection{Normal Forms}

\subsubsection*{Lists/Map}
{\fontfamily{pcr}\selectfont
\vspace{0.5cm}
$\lambda$ (a: *) $\rightarrow$ $\lambda$ (b: *) $\rightarrow$ $\lambda$ (f: a $\rightarrow$ b) $\rightarrow$ $\lambda$ (xs: $\forall$ (List: *)
$\rightarrow$ $\forall$ (Cons: $\forall$ (head: a) $\rightarrow$ $\forall$ (tail: List) $\rightarrow$ List) $\rightarrow$ $\forall$ (Nil: List) $\rightarrow$ List)
$\rightarrow$ xs ($\forall$ (List: *) $\rightarrow$ $\forall$ (Cons: $\forall$ (head: b) $\rightarrow$ $\forall$ (tail: List) $\rightarrow$ List)
$\rightarrow$ $\forall$ (Nil: List) $\rightarrow$ List) ($\lambda$ (head: a) $\rightarrow$ $\lambda$ (tail: $\forall$ (List: *) $\rightarrow$
$\forall$ (Cons: $\forall$ (head: b) $\rightarrow$ $\forall$ (tail: List) $\rightarrow$ List) $\rightarrow$ $\forall$ (Nil: List)
$\rightarrow$ List) $\rightarrow$ $\lambda$ (List: *) $\rightarrow$ $\lambda$ (Cons: $\forall$ (head: b) $\rightarrow$ $\forall$
(tail: List) $\rightarrow$ List) $\rightarrow$ $\lambda$ (Nil: List) $\rightarrow$ Cons (f head) (tail List Cons Nil))
($\lambda$ (List: *) $\rightarrow$ $\lambda$ (Cons: $\forall$ (head: b) $\rightarrow$ $\forall$ (tail: List) $\rightarrow$
List) $\rightarrow$ $\lambda$ (Nil: List) $\rightarrow$ Nil)
}

\newpage
\subsection{Prelude Base Library}

\begin{lstlisting}[mathescape=true]

             data Nat: Type :=
                  (Zero: Unit $\rightarrow$ Nat)
                  (Succ: Nat $\rightarrow$ Nat)

             data List (A: Type) : Type :=
                  (Nil: Unit $\rightarrow$ List A)
                  (Cons: A $\rightarrow$ List A $\rightarrow$ List A)

           record list: Type :=
                  (len: List A $\rightarrow$ integer)
                  ((++): List A $\rightarrow$ List A $\rightarrow$ List A)
                  (map: (A,B: Type) (A $\rightarrow$ B) $\rightarrow$ (List A $\rightarrow$ List B))
                  (filter: (A $\rightarrow$ bool) $\rightarrow$ (List A $\rightarrow$ List A))

           record String: List Nat := List.Nil

             data IO: Type :=
                  (getLine: (String $\rightarrow$ IO) $\rightarrow$ IO)
                  (putLint: String $\rightarrow$ IO)
                  (pure: () $\rightarrow$ IO)

           record IO: Type :=
                  (data: String)
                  ([>>=]: ...)

           record Morte: Type :=
                  (recursive: IO.replicateM Nat.Five
                              (IO.[>>=] IO.data Unit IO.getLine IO.putLine))

\end{lstlisting}


\newpage
\begin{thebibliography}{9}

\subsection*{Category Theory}
\bibitem{maclane}    S.MacLane \textit{Categories for the Working Mathematician} 1972
\bibitem{lawvere}    W.Lawvere \textit{Conceptual Mathematics} 1997
\bibitem{curien}     P.Curien \textit{Category theory: a programming language-oriented introduction} 2008

\subsection*{Pure Type Systems}
\bibitem{martinlof}  P.Martin-Löf \textit{Intuitionistic Type Theory} 1984
\bibitem{coquand}    T.Coquand \textit{The Calculus of Constructions.} 1988
\bibitem{henk}       E.Meijer \textit{Henk: a typed intermediate language} 1997
\bibitem{barendregt} H.Barendregt \textit{Lambda Calculus With Types} 2010

\subsection*{Inductive Type Systems}
\bibitem{pfenning}   F.Pfenning \textit{Inductively defined types in the Calculus of Constructions} 1989
\bibitem{wadler}     P.Wadler \textit{Recursive types for free} 1990
\bibitem{gambino}    N.Gambino \textit{Wellfounded Trees and Dependent Polynomial Functors} 1995
\bibitem{dybjer}     P.Dybjer \textit{Inductive Famalies} 1997
\bibitem{jacobs}     B.Jacobs \textit{(Co)Algebras) and (Co)Induction} 1997
\bibitem{vene}       V.Vene \textit{Categorical programming with (co)inductive types} 2000
\bibitem{guevers}    H.Geuvers \textit{Dependent (Co)Inductive Types are Fibrational Dialgebras} 2015

% \subsection*{Pi Calculus}
% \bibitem{comm}       Robin Milner. \textit{A Calculus of Communicating Systems.} 1986.
% \bibitem{commpi}     Robin Milner. \textit{Communicating and Mobile Systems: The $\pi$-calculus.} 1999.
% \bibitem{polypi}     Robin Milner. \textit{The Polyadic $\pi$-Calculus: A Tutorial.} 1993.

\subsection*{Homotopy Type Systems}
\bibitem{streicher0} T.Streicher \textit{A groupoid model refutes uniqueness of identity proofs} 1994
\bibitem{streicher}  T.Streicher \textit{The Groupoid Interpretation of Type Theory} 1996
\bibitem{jacobs2}    B.Jacobs \textit{Categorical Logic and Type Theory} 1999
\bibitem{awodey}     S.Awodey \textit{Homotopy Type Theory and Univalent Foundations} 2013
\bibitem{huber}      S.Huber \textit{A Cubical Type Theory} 2015
\bibitem{joyal}      A.Joyal \textit{What is an elementary higher topos} 2014
\bibitem{mortberg}   A.Mortberg \textit{Cubical Type Theory: a constructive univalence axiom} 2017

\end{thebibliography}
\newpage

\end{document}
