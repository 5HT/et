% copyright (c) 2015 Synrc Research Center

\documentclass[11pt,oneside]{article}

\input{synrc.tex}
\begin{document}

\thispagestyle{empty}
\begin{center}

\begin{minipage}[t]{2cm}
    \includegraphics[scale=0.4]{img/S}
\end{minipage}
\begin{minipage}[t]{12cm}
    \begin{flushright}
        \textsc{{\Large {\bf {\color{Blue}syn}{\color{OrangeRed}rc} research center s.r.o.}}}\\
        \textsc{Roháčova 141/18, Praha 3 13000, Czech Republic}\\
    \end{flushright}
\end{minipage}

\vspace{3cm}

    \vspace{3cm}   {\Large \bf Compilation of general purpose functional language\\ \vspace{0.2cm}
                               to minimal pure type system core\\ }\par
    \vspace{0.3cm} {\Large Technical Article\par}
    \vspace{0.3cm} {\Large Maxim Sokhatsky, Synrc Research Center\par}
    \vspace{4cm}   {\Large Kyiv 2016}

\end{center}

\newpage
\vspace{2cm}
\tableofcontents
\newpage
\section{Introduction}

\vspace{1cm}

%\vspace{0.5cm}

\subsection{Verifiable Functional Compiler}

   \paragraph{}
   This article describes the frontend language {\bf Exe} along with its categorical semantic
   that compiles to a pure type system minimal core {\bf Om} --- the
   non-recursive subset of dependent type theory from which you can extract: LLVM code,
   untyped lambda code with erased type information, or even $System\ F_\omega$ programs.
   As a top-level task we expect to produce lean verifiable functional compiler pipeline,
   but as an milestone task we just produce concise working prototype in Erlang language.

\subsection{General Purpose Functional Language Exe}

   \paragraph{}
   General purpose function language with functors, lambdas on types, recursive algebraic types,
   higher order functions and embedded process calculus with corecursion, free monad for effects encoding.
   This language will be called Exe and dedicated to be high level general purpose functional
   programming language frontend to small core of dependent type system without recursion called Om.
   This language indended to be useful enough to encode KVS, N2O and BPE applications.

\subsection{Intermediate Language Om}

   \paragraph{}
   An intermediate Om language is base on Henk\cite{henk} languages described first
   by Erik Meyer and Simon Peyton Jones in 1997. Leter on in 2015 Morte impementation
   of Henk design appeared in Haskell, using Boem-Berrarducci encoding of non-recursive lamda terms.
   It is based only on $\pi$, $\lambda$ and $apply$ constructions, one axiom and four deduction rules.
   The design of Om language resemble Henk and Morte both design and implementation.
   This language indended to be small, conside, easy provable and clean and produce
   verifiable peace of code that can be distributed over the networks and compiled at target with
   safe linkage.

\subsection{Target Erlang VM and LLVM platforms}

   \paragraph{}
   This works expect to compile to limited target platforms. For now Erlang, Haskell and LLVM is awaiting.
   Erlang version is expected to be useful both on LING and BEAM Erlang virtual machines.

\newpage
\section{General Purpose Language}
\vspace{0.3cm}

   \subsection{Category Theory, Programs and Functions}
   Category theory is widely used as an instrument for mathematicians for software analisys.
   Category theory could be treated as an abstract algebra of functions. Let's define an Category
   formally: {\bf Category} consists of two lists: the one is morphisms (arrows) and the second is
   objects (domains and codomains of arrows) along with assoociative operation of composition and
   unit morphism that exists for all objects in category.

   \paragraph{}
   The formation axoims of objects and arrows are not given here and autopostulating yet. Formation axoims
   will be introduced during exponential definition. Objects $A$ and $B$ of an arrow $f: A \rightarrow B$
   are called {\bf domain} and {\bf codomain} respectively.

   \paragraph{}
   Intro axioms -- associativity of composition and left/right unit arrow compisitions show that
   categories are actually typed monoids, which consist of morphisms and operation of composition.
   There are many language to show the semantic of categories such as commutative diagrams and string diagrams
   however here we define here in proof-theoretic manner:

\begingroup
\parbox[t][][l]{0.60\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash f: A \rightarrow B$ }
\AxiomC{$\Gamma\ \vdash g: B \rightarrow C$ }
\BinaryInfC{$\Gamma \vdash g \circ f : A \rightarrow C $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash f : B \rightarrow A$ }
\AxiomC{$\Gamma \vdash g : C \rightarrow B$ }
\AxiomC{$\Gamma \vdash h : D \rightarrow C$ }
\TrinaryInfC{$\Gamma \vdash (f \circ g) \circ h = f \circ (g \circ h) : D \rightarrow A $}
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$$ }
\UnaryInfC{$\Gamma \vdash id_A : A \rightarrow A $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash f: A \rightarrow B$ }
\UnaryInfC{$\Gamma \vdash f \circ id_A = f : A \rightarrow B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash f: A \rightarrow B$ }
\UnaryInfC{$\Gamma \vdash id_B \circ f = f : A \rightarrow B $}
\end{prooftree}

}
\endgroup

\paragraph{}
Composition shows an ability to connect the result space of the previous evaluation (codomain)
and the arguments space of the next evaluation (domain). Composition is fundamental property of morphisms
that allows us to chain evaluations.

\paragraph{}
\begin{tabular}{lll}
$1.$ & $A: *$\\
$2.$ & $A: *\ ,\ B: * \implies f: A \rightarrow B$\\
$3.$ & $f: B \rightarrow C\ ,\ g: A \rightarrow B \implies f \circ g : A \rightarrow C$\\
$4.$ & $(f \circ g) \circ h = f \circ (g \circ h)$\\
$5.$ & $A \implies id : A \rightarrow A$\\
$6.$ & $f \circ id = f$\\
$7.$ & $id \circ f = f$\\
\end{tabular}

\newpage
\subsection{Algebraic Types and Cartesian Categories}

After composition operation of construction of new objects with morphisms we introduce
operation of construction cartesian product of two objects $A$ and $B$ of a given
category along with morphism product $<f,g>$ with a common domain, that is needed
for full definition of cartesian product of $A \times B$.

\paragraph{}
This is an internal language of cartesian category, in which for all two selected objects there is an object
of cartesian product (sum) of two objects along with its $\bot$ terminal (or $\top$ coterminal) type.
Exe languages is always equiped with product and sum types.

\paragraph{}
Product has two eliminators $\pi$ with an common domain, which are also called projections of an product.
The sum has eliminators $i$ with an common codomain.
Note that eliminators $\pi$ and $i$ are isomorphic, that is $\pi \circ \sigma = \sigma \circ \pi = id$.

\begingroup
\parbox[t][][l]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma\ x: A \times B$ }
\UnaryInfC{$\Gamma \vdash \pi_1\ : A \times B \rightarrow A$;
           $\Gamma \vdash \pi_2\ : A \times B \rightarrow B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash\  a:A$ }
\AxiomC{$\Gamma \vdash\  b:B$ }
\BinaryInfC{$\Gamma \vdash\ (a,b) : A \times B$ }
\end{prooftree}

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash\ \top$ }
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.60\textwidth}{

\begin{prooftree}
\AxiomC{}
\UnaryInfC{$\Gamma \vdash\ \bot$ }
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash\  a:A$ }
\AxiomC{$\Gamma \vdash\  b:B$ }
\BinaryInfC{$\Gamma\vdash a\ |\ b : A \otimes B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ x: A \otimes B$ }
\UnaryInfC{$\Gamma \vdash \i_1: A \rightarrow A \otimes B$;
           $\Gamma \vdash \i_2: B \rightarrow A \otimes B$}
\end{prooftree}

}
\endgroup

   \paragraph{}

   The $\bot$ type in Haskell is used as {\bf undefined} type (empty sum component presented in all types), that
   is why Hask category is not based on cartesian closed but CPO\cite{cpo}. The $\bot$ type has no values.
   The $\top$ type is known as unit type or zero tuple $()$ often
   used as an default argument for function with zero arguments.
   Also we include here an axiom of morphism product which is given during full definition
   of product using commutative diagram. This axiom is needed for applicative
   programming in categorical abstract machine. Also consider co-version of this
   axiom for $[f,g]: B+C \rightarrow A$ morphism sums.

\begin{prooftree}
\AxiomC{$\Gamma \vdash\ f:A \rightarrow B$ }
\AxiomC{$\Gamma \vdash\ g:A \rightarrow C$ }
\AxiomC{$\Gamma \vdash\ B \times C$ }
\TrinaryInfC{$\Gamma \vdash\ \langle f,g \rangle : A \rightarrow B \times C$ }
\end{prooftree}

\begin{center}
%$(f \circ g) \circ h = f \circ (g \circ h)$\\
%$f \circ id = f$\\
%$id \circ f = f$\\
$\pi_1 \circ \langle f, g \rangle = f$\\
$\pi_2 \circ \langle f, g \rangle = g$\\
$\langle f \circ \pi_1, f \circ \pi_2 \rangle = f$\\
$\langle f, g \rangle \circ h = \langle f \circ h, g \circ h \rangle$\\
$\langle \pi_1, \pi_2 \rangle = id$\\
\end{center}

\newpage
   \subsection{Exponential, $\lambda$-calculus and Cartesian Closed Categories}
   Being an internal language of cartesian closed category, lambda calculus except variables and constants
   provides two operations of abstraction and applications which defines complete evaluation language
   with higher order functions, recursion and corecursion, etc.

   \paragraph{}
   To explain functions from the categorical point of vew we need to define categorica exponential
   $f: A^B$, which are analogue to functions $f: A \rightarrow B$.
   As we already defined the products and terminals we could define an exponentials with three
   axioms of function construction, one eliminator of application with apply a function to its argument
   and axiom of currying the function of two arguments to function of one argument.

\begingroup
\parbox[t][][l]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma  x:A \vdash M : B$}
\UnaryInfC{$\Gamma \vdash \lambda\ x\ .\ M : A \rightarrow B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ f:A \rightarrow B$ }
\AxiomC{$\Gamma\ a:A$ }
\BinaryInfC{$\Gamma \vdash apply\ f\ a\ : (A \rightarrow B) \times A \rightarrow B$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash f: A \times B \rightarrow C$ }
\UnaryInfC{$\Gamma \vdash curry\ f : A \rightarrow (B \rightarrow C)$}
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.60\textwidth}{

\begin{center}
$apply \circ \langle (curry\ f) \circ \pi_1 , \pi_2 \rangle = f$\\
$curry\ apply \circ \langle g \circ \pi_1, \pi_2 \rangle) = g$\\
$apply \circ \langle curry\ f, g \rangle = f \circ \langle id , g\rangle$\\
$(curry\ f) \circ g = curry\ (f \circ \langle g \circ \pi_1,\pi_2\rangle)$\\
$curry\ apply = id$\\
\end{center}

\begin{center}
Objects : $\bot\ |\ \rightarrow\ |\ \times$\\
Morphisms : $id\ |\ f \circ g\ |\ \langle f, g \rangle\ |\ apply\ |\ \lambda\ |\ curry$
\end{center}

}
\endgroup

  \subsection{Functors}

  Functor comes as a notion of morphisms in categories whose objects are categories.
  Functors should preserve compositions of arrows and identities, otherwise it would
  be impossible to deal with categories. One level up is notion of morphism between categories whose
  objects are Functors, such morphisms are called natural transformations. Here we need
  only functor definition which is needed as general type declarations.

\begin{prooftree}
\AxiomC{$\Gamma \vdash f\ :\ A \rightarrow B$}
\UnaryInfC{$\Gamma \vdash F\ f\ :\ (A \rightarrow B) \rightarrow (F\ a \rightarrow F\ b)$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash id_A\ :A \rightarrow A$}
\UnaryInfC{$\Gamma \vdash F\ id_A\ =\ id_{F A}\ :\ F\ A \rightarrow F\ A$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma \vdash f\ :B \rightarrow C,\ g : A \rightarrow B$}
\UnaryInfC{$\Gamma \vdash F\ f \circ F\ g\ =\ F (f \circ g)\ :\ F\ A \rightarrow F\ C$}
\end{prooftree}

   We start thinking of functors on dealing with typed theories, because functors usually
   could be seen as higher order type con

\newpage

   \subsection{Recursive Types}

  As was shown by Wadler\cite{recursive} we could deal with recusrive equations having
  three axioms: one $fix: (A \rightarrow A) \rightarrow A$ fixedpoint axiom,
  and axioms $in: F\ T \rightarrow T$ and $out: T \rightarrow F\ T$ of recursion direction. We need to
  define fixed point as axiom because we can't define recursive axioms. This axioms
  also needs functor axiom defined earlier.

  \paragraph{}
  There is two types of recursion: one is least fixed point (as $rec\ A = 1 + (A,rec)$ or $rec\ A = A + (rec,rec)$),
  in other words the recursion with a base (terminated with a bounded value), lists are trees are
  examples of such recursive structures (so we call induction recursive sums); and the second
  is greatest fixed point or recursion withour base (as $rec\ A = (A,A)$) --- such kind of
  recursion on infinite lists (codata, streams, coinductive types) we can call recursive products.

  \paragraph{}
  As we know there are several ways to appear for variable in recursive algebraic type.
  Least fixpoint are known as an recursive expressions that have a base of recursion
  Both recursive and corecursive datatypes could be encoded using Boem-Berarducci encoding
  as an non-recursive definitions of folds that include in indentity signature all the
  constructor components of (co)inductive type.

\begingroup
\parbox[t][][l]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma  \vdash M : F\ (\mu\ F)$}
\UnaryInfC{$\Gamma \vdash in_{\mu F}\ M : \mu\ F$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma  \vdash M : \mu F$}
\UnaryInfC{$\Gamma \vdash out_{\mu F}\ M : F\ (\mu\ F)$}
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.60\textwidth}{


\begin{prooftree}
\AxiomC{$\Gamma  \vdash M : A \rightarrow A$}
\UnaryInfC{$\Gamma \vdash fix\ M : A$}
\end{prooftree}

}
\endgroup

   Not that there is a class of recursive types such when fixpoint is defined in codomain of morphism,
   such terms could not be normalized.

\vspace{1cm}



\newpage
   \subsection{Algebras}

   F-Algebras gives us a categorical understanding recursive types.
   Let $F : C \rightarrow C$ be an endofunctor on category $C$.
   An F-algebra is a pair $(C, \phi)$, where C is an object and $\phi\ : F\ C \rightarrow C$
   an arrow in the category C. The object C is the carrier and the functor
   F is the signature of the algebra. Reversing arrows gives us F-Coalgebra.

\vspace{1cm}

\begin{center}
\begin{tabular}{lcl}
\begin{tikzcd}
  F\ C \arrow{d}[left]{F\ f} \arrow{r}{\varphi} & C \arrow{d}{f} \\
  F\ D \arrow{r}{\psi} & D \end{tikzcd} & & \begin{tikzcd}
  C \arrow{d}[left]{f} \arrow{r}{\varphi} & F\ C \arrow{d}{F\ f} \\
  D \arrow{r}{\psi} & F\ D \end{tikzcd} \\
  \ & \  &\  \\
  $f \circ \varphi = \psi \circ F\ f$ & & $\psi \circ f =  F\ f \circ \varphi$ \\
\end{tabular}
\end{center}

  \subsection{Initial Algebras}

  A F-algebra $(\mu F, in)$ is the initial F-algebra if for any F-algebra $(C, \varphi)$
  there exists a unique arrow $\llparenthesis \varphi \rrparenthesis : \mu F \rightarrow C$ where $f = \llparenthesis \varphi \rrparenthesis$
  and is called catamorphism. Similar a F-coalgebra $(\nu F, out)$ is the terminal
  F-coalgebra if for any F-coalgebra $(C, \varphi)$ there exists unique arrow
  $\llbracket \varphi \rrbracket : C \rightarrow \nu F$ where $f = 
  \llbracket \varphi \rrbracket$

\begin{center}
\begin{tabular}{lcl}
\begin{tikzcd}
  F\ \mu F \arrow{d}[left]{F\ \llparenthesis \varphi \rrparenthesis} \arrow{r}{in} & \mu F \arrow{d}{\llparenthesis \varphi \rrparenthesis} \\
  F C \arrow{r}{\varphi} & C \end{tikzcd} & & \begin{tikzcd}
  C \arrow{d}[left]{ \llbracket \varphi \rrbracket} \arrow{r}{\phi} & F\ C\arrow{d}{F\ \llbracket \varphi \rrbracket} \\
  \nu F \arrow{r}{out} & F \nu F\end{tikzcd} \\
  \ & \  &\  \\
  $f \circ in = \varphi \circ F\ f \equiv f = \llparenthesis \varphi \rrparenthesis$& &
  $out \circ f = F\ f \circ \varphi \equiv f = \llbracket \varphi \rrbracket$ \\
\end{tabular}
\end{center}

\newpage
   \subsection{Process Calculus}
   Thr $\pi$-calculus of processes by Robert Milner is basic formalism for distributed
   computational theory and its implementations. From origin times of CSP developed by Hoare,
   Milner significanly evolved the theory and adopted it to contemporary telecommunication requirements,
   such as hangovers in mobile networks.

  \subsection*{Process and Protocols}
  We announce process and a fundamental function type of a special signature with protocol $\Sigma$ and
  state $X$.

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash E, \Sigma, X$ }
\AxiomC{$\Gamma\ \vdash action : \Sigma \times X \rightarrow \Sigma \times X$ }
\BinaryInfC{$\Gamma \vdash {spawn}\ action : \pi_(\Sigma,X) $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash pid : \pi_(\Sigma,X)$ }
\AxiomC{$\Gamma\ \vdash msg : \Sigma$ }
\BinaryInfC{$\Gamma \vdash join\ msg\ pid : \Sigma \times \pi_\Sigma \xrightarrow{\bullet} \Sigma$;
            $\Gamma \vdash send\ msg\ pid : \Sigma \times \pi_\Sigma \rightarrow \Sigma$}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash L : A + B, R : X + Y$ }
\AxiomC{$\Gamma\ \vdash M : A \rightarrow X, N : B \rightarrow Y$ }
\BinaryInfC{$\Gamma \vdash receive\ L\ M\ N : L \xrightarrow{\bullet} R$}
\end{prooftree}

\paragraph{}

  \subsection*{Process Algebra}

  Алгебра процесів визначає базові операції мультиплексування двох чи декількох
  протоколів в рамках одного процесу (добуток), а також паралельного та повністю
  ізольованого запуску включно зі стеком та областю памяті (сума) на
  віртуальній машині.

\begin{center}
\begin{tabular}{lcl}
$\oplus$   &:& $\pi \parallel \pi$\\
$\otimes$  &:& $\pi \mid \pi$\\
\end{tabular}
\end{center}

%  \subsubsection*{Типи процесів}
%
%\begin{center}
%\begin{tabular}{lll}
%         $action$ &:& ${proc}_{Proc}\  (BPE\ |\ \Sigma) \times process \rightarrow process$ \\
%          $event$ &:& ${proc}_{App}\   (N2O\ |\ \Sigma) \times cx \rightarrow cx$ \\
%      $operation$ &:& ${proc}_{Store}\ (KVS\ |\ \Sigma) \times container \rightarrow container$ \\
%\end{tabular}
%\end{center}

\newpage
   \subsection{Intuitionistic Type Theory}

   \paragraph{}
   Розбудовуючи певний фреймворк чи систему конструктивними методами
   так чи інакше доведеться зробити певний вибір у мові та способі кодування.
   Так при розробці теорії абстрактної алгебри в Coq були використані
   поліморфні індуктивні структури\cite{coqalg}. Однак Agda та Idris використувують
   для побудови алгебраїчної теорії типи класів, а у Idris взагалі відсутні
   поліморфірні індуктивні структури та коіндуктивні структури. В Lean
   теж відсутні коіндуктивні структури проте повністю реалізована теорія
   HoTT на нерекурсивних поліморфних структурах що обєднує основні чотири
   класи математичних теорій: логіка, топологія, теорія множин, теорія типів.
   Як було показано Стефаном Касом\cite{kaes}, одна з
   стратегій імплементації типів класів --- це використання поліморфних структур.
   Хоча в Lean також підтримуються типи класів нами була вибрана стратегія
   імплементації нашої теорії з використаннями нерекурсивних індуктивних структур,
   що дозволить нам оперувати з персистентними структурами на низькому рівні.
   Крім того такий спосіб кодування ієрархій повністю відповідає семантиці Erlang,
   де немає типів класів, а дані передаються запаковані в кортежі-структури.

  \subsection{Logic and Quantification}

Далі йдуть квантори $\forall$ та $\exists$ які теж виражаються як конструкції типів:

\begingroup
\parbox[t][][l]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma\ x: A \vdash B$ }
\AxiomC{$\Gamma\ \vdash A$ }
\BinaryInfC{$\Gamma\ \vdash \Pi (x : A) B $}
\end{prooftree}

\begin{prooftree}
\AxiomC{$\Gamma\ x: A \vdash B$ }
\AxiomC{$\Gamma\ \vdash A$ }
\BinaryInfC{$\Gamma\ \vdash \Sigma (x : A) B $}
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.60\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash a : A$ }
\AxiomC{$\Gamma\ x : A \vdash B$ }
\AxiomC{$\Gamma\ b : B (x=a)$ }
\TrinaryInfC{$\Gamma\ \vdash (a,b) : \Pi (x : A) B $}
\end{prooftree}


\begin{prooftree}
\AxiomC{$\Gamma\ \vdash a : A$ }
\AxiomC{$\Gamma\ x : A \vdash B$ }
\AxiomC{$\Gamma\ b : B (x=a)$ }
\TrinaryInfC{$\Gamma\ \vdash (a,b) : \Sigma (x : A) B $}
\end{prooftree}

}
\endgroup

\begingroup
\parbox[t][][l]{0.40\textwidth}{

\begin{prooftree}
\AxiomC{$\Gamma\ \vdash x: A$ }
\AxiomC{$\Gamma\ \vdash x': A$ }
\BinaryInfC{$\Gamma\ \vdash Id_A (x,x')$}
\end{prooftree}

}
\hspace{0.1cm}
\parbox[t][][r]{0.60\textwidth}{

}\endgroup


\begin{center}
\begin{tabular}{lll}
  рефлексивність &:& $Id_A(a,a)$ \\
  підстановка    &:& $Id_A(a,a') \rightarrow B(x=a) \rightarrow B(x=a')$ \\
  симетричність  &:& $Id_A(a,b) \rightarrow Id_A(b,a)$  \\
  транзитивність &:& $Id_A(a,b) \rightarrow Id_A(b,c) \rightarrow Id_A(a,c)$ \\
  конгруентність &:& $(f: A \rightarrow B) \rightarrow Id_A(x,x') \rightarrow Id_B(f(x),f(x'))$ \\
\end{tabular}
\end{center}

\newpage

  \section{Intermediate Language}
\vspace{1cm}

   \subsection{Om Language Definition}
\vspace{0.5cm}
   Om resemble both the Henk theory of pure type system and $\lambda C$ calculus of constructions
   and Morte Core Specification

\begin{lstlisting}
    EXPR :=                     EXPR             EXPR 
          | "\"   "(" LABEL ":" EXPR ")" "arrow" EXPR 
          | "\/"  "(" LABEL ":" EXPR ")" "arrow" EXPR 
          |                     EXPR     "arrow" EXPR 
          |           LABEL                           
          | "*"                                       
          | "[]"                                      
          |       "("           EXPR ")"              
\end{lstlisting}

During forward pass we stack applications (except typevars), then
on reaching close paren ")" we perform backward pass and stack arrows,
until neaarest unstacked open paren "(" appeared (then we just return
control to the forward pass).

\paragraph{}
We need to preserve applies to typevars as they should
be processes lately on rewind pass, so we have just typevars bypassing rule.
On the rewind pass we stack lambdas by matching arrow/apply signatures
where typevar(x) is an introduction of variable "x" to the Gamma context.

\begin{center}
                   $apply: (A \rightarrow B) \times A \rightarrow B$ \\
                  $lambda: arrow\ (app\ (typevar\ x)\ ,\ A)\ B$ \\
\end{center}


   \subsection{Abstract Syntax Tree}

\begin{center}
\begin{tabular}{lcl}
      $E$ & :=& $K$ \\
          & | & $x$ \\
          & | & $E E$ \\
          & | & $\lambda (x: E) \rightarrow E$ \\
          & | & $\Pi (x: E) \rightarrow E$ \\
\end{tabular}
\end{center}

\newpage

  \subsection{Encoding Basic Type Constructors}
\vspace{1cm}
\paragraph{}
   We usually define inductive type in $\lambda C$ theorem provers by specifying
   types as sum of lambda type constructors with return type as a definition type

\begin{lstlisting}
   type List (A: *) : * = Nil: () -> List A
                        | Cons: A -> List A -> List A
\end{lstlisting}

   However we can omit return type from encoding but specify parameters of
   constructors as named lambdas in Om tree:

\begin{lstlisting}
   type Product (A: *) (B: *) : * =        Make (a: A)      (b: B)
   type Sum (A: *) (B: *)     : * =        Sum  (a: A)      (b: B)
   type Option  (A: *)        : * = None | Some (value: A)
   type List    (A: *)        : * = Nil  | Cons (head: A)   (tail: List)
   type Unit                  : * = Make
\end{lstlisting}

  \subsection{Samples of Exe programs}

\begin{lstlisting}

  $ cat List/(++)
  '++'[a:*](as1: #List a, as2: #List a): #List a ->
    as1 List Cons (as2 List Cons Nil)

\end{lstlisting}

\newpage
\begin{thebibliography}{9}

\bibitem{henk}       E.Meijer, S. Peyton Jones \textit{Henk: a typed intermediate language} 1984
\bibitem{recursive}  P.Wadler \textit{Recursive types for free!} 2014 % http://homepages.inf.ed.ac.uk/wadler/papers/free-rectypes/free-rectypes.txt
\bibitem{baastad}    P.Wadler \textit{Monads for functional programming}
\bibitem{lof}        Per Martin-Löf \textit{Intuitionistic Type Theory.} 1984
\bibitem{awodey}     S.Awodey \textit{Category Theory} 2010
\bibitem{debjer}     P.Dybjer \textit{Inductive Famalies} 1997
\bibitem{vene}       V.Vene \textit{Categorical programming with (co)inductive types} 2000
\bibitem{baer}       A.Baer \textit{Programming with Algebraic Effects and Handlers} 2012
\bibitem{curien1}    PL. Curien \textit{Category theory: a programming language-oriented introduction} 2008
\bibitem{lawvere}    William Lawvere. \textit{Conceptual Mathematics.} 1997.
\bibitem{mclane}     Сандерс Мак Лейн. \textit{Категории для работающего математика.} 2004.
\bibitem{bakur}      И.Бакур, А.Деляну. \textit{Введение в теорию категори и функторов.} 1972.
\bibitem{comm}       Robin Milner. \textit{A Calculus of Communicating Systems.} 1986.
\bibitem{commpi}     Robin Milner. \textit{Communicating and Mobile Systems: The $\pi$-calculus.} 1999.
\bibitem{polypi}     Robin Milner. \textit{The Polyadic $\pi$-Calculus: A Tutorial.} 1993.
\bibitem{coqhuet}    T.Coquand, G.Huet \textit{The Calculus of Constructions.} 1988
\bibitem{chipvm}     A.Chlipala \textit{Certified Programming with Dependent Types} 2015
\bibitem{idris}      E.Brady \textit{Programming in IDRIS: A Tutorial} 2015
\bibitem{mcbrideapp} C.McBride, R.Patterson \textit{Applicative programming with effects} 2002
\bibitem{andjelko}   S.Andjelkovic \textit{A family of universes for generic programming} 2011
\bibitem{alacarte}   W.Swierstra \textit{Data types a` la carte} 2011
\bibitem{catlogic}   B.Jacobs \textit{Categorical Logic and Type Theory} 1999
\bibitem{pointfree}  A.Cuhna,J.Pinto,J.Proenca \textit{A Framework for Point-Free Program Transformation}
\bibitem{kaes}       S.Kaes \textit{http://tuprints.ulb.tu-darmstadt.de/epda/000544/diss.pdf} 2005
\bibitem{cpo}        NA.Danielsson,J.Hughes,J.Gibbons \textit{Fast and Loose Reasoning is Morally Correct} 2006

\end{thebibliography}

\end{document}
